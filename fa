package ru.sber.poirot.notifications.admin

import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.web.bind.annotation.*
import ru.sber.permissions.HAS_MANAGE_NOTIFICATIONS
import ru.sber.poirot.audit.AuditClient
import ru.sber.poirot.notifications.admin.dto.CreateRequest
import ru.sber.poirot.notifications.admin.dto.NotificationResponse
import ru.sber.poirot.notifications.admin.dto.UpdateRequest

@RestController
@RequestMapping("/api/adminNotification")
class AdminNotificationController(
    private val service: AdminNotifications,
    private val auditClient: AuditClient
) {

    @PostMapping("/create")
    @PreAuthorize(HAS_MANAGE_NOTIFICATIONS)
    suspend fun create(@RequestBody request: CreateRequest): NotificationResponse =
        auditClient.audit(event = "NOTIFICATION_CREATE", details = "request=$request") {
            service.create(request)
        }

    @PutMapping("/update")
    @PreAuthorize(HAS_MANAGE_NOTIFICATIONS)
    suspend fun update(@RequestBody request: UpdateRequest): Unit =
        auditClient.audit(event = "NOTIFICATION_UPDATE", details = "request=$request") {
            service.update(request)
        }

    @DeleteMapping("/archive/{id}")
    @PreAuthorize(HAS_MANAGE_NOTIFICATIONS)
    suspend fun archive(@PathVariable id: Long): Unit =
        auditClient.audit(event = "NOTIFICATION_ARCHIVE", details = "id=$id") {
            service.archive(id)
        }

    @GetMapping("/fetchAll")
    @PreAuthorize(HAS_MANAGE_NOTIFICATIONS)
    suspend fun fetchAll(): List<NotificationResponse> =
        auditClient.audit(event = "NOTIFICATION_FETCH_ALL") {
            service.fetchAll()
        }
}package ru.sber.poirot.notifications.admin.impl

import org.springframework.stereotype.Service
import ru.sber.poirot.CurrentUser
import ru.sber.poirot.exception.FrontException
import ru.sber.poirot.notifications.admin.AdminNotifications
import ru.sber.poirot.notifications.admin.dto.*
import ru.sber.poirot.notifications.common.error.NotificationErrorCode.NOTIFICATION_NOT_FOUND_OR_ARCHIVED
import ru.sber.poirot.notifications.roles.RolesDao
import ru.sber.poirot.notifications.websocket.BroadcastRegistry

@Service
class AdminNotificationsImpl(
    private val adminNotificationsDao: AdminNotificationsDao,
    private val rolesDao: RolesDao,
    private val currentUser: CurrentUser,
) : AdminNotifications {

    override suspend fun create(request: CreateRequest): NotificationResponse {
        val newRoleIds = chooseRoleIds(request.roleIds)
        val notification = request.adminNotification(currentUser.userName(), newRoleIds)
        adminNotificationsDao.insert(notification)

        BroadcastRegistry.publish(listOf(notification.toFeedResponse()))

        return notification.notificationResponse()
    }

    override suspend fun update(request: UpdateRequest) {
        if (!adminNotificationsDao.existsNotArchivedWithId(request.id)) {
            throw FrontException(NOTIFICATION_NOT_FOUND_OR_ARCHIVED)
        }

        val notification = request.adminNotification(chooseRoleIds(request.roleIds))
        adminNotificationsDao.merge(notification)

        BroadcastRegistry.publish(listOf(notification.toFeedResponse()))
    }

    override suspend fun archive(id: Long) {
        val notification = adminNotificationsDao.fetchById(id).apply { archive = true }
        adminNotificationsDao.merge(notification)

        BroadcastRegistry.publish(listOf(notification.toFeedResponse()))
    }

    override suspend fun feed(): Pair<List<FeedResponse>, Set<Int>> {
        val userRoleIds = currentUser.rolesIds().toSet()
        val feed = adminNotificationsDao.feed(userRoleIds).map { it.toFeedResponse() }
        return feed to userRoleIds
    }

    override suspend fun fetchAll(): List<NotificationResponse> =
        adminNotificationsDao.fetchAll().map { it.notificationResponse() }

    private suspend fun chooseRoleIds(roleIds: List<Int>?): List<Int> = when {
        roleIds.isNullOrEmpty() -> rolesDao.getAllRoleIds()
        else -> roleIds
    }
}package ru.sber.poirot.notifications.admin.impl

import org.springframework.stereotype.Repository
import ru.sber.poirot.engine.datasources.PoirotDatabaseNames.POIROT_USERS
import ru.sber.poirot.engine.datasources.transaction.TransactionTemplates
import ru.sber.poirot.engine.ds.refreshable.RefreshableSet
import ru.sber.poirot.engine.ds.refreshable.Refreshables.refreshableSet
import ru.sber.poirot.engine.ds.refreshable.delayers.about1Min
import ru.sber.poirot.engine.ds.refreshable.incrementOnChange
import ru.sber.poirot.engine.dsl.Order.DESC
import ru.sber.poirot.engine.dsl.existsAny
import ru.sber.poirot.engine.dsl.findAll
import ru.sber.poirot.engine.dsl.findFirst
import ru.sber.poirot.exception.FrontException
import ru.sber.poirot.notifications.admin.impl.DslAdminNotificationsDao.FeedableHolder.feedable
import ru.sber.poirot.notifications.common.entity.AdminNotification
import ru.sber.poirot.notifications.common.error.NotificationErrorCode.NOTIFICATION_NOT_FOUND
import ru.sber.poirot.notifications.common.metamodel.adminNotification
import ru.sber.poirot.refreshable.InitRefreshables
import ru.sber.poirot.utils.inTransactionWithReactorContext
import ru.sber.sql.persister.AsyncGraphPersister
import java.time.LocalDateTime.now

@Repository
class DslAdminNotificationsDao(
    private val persister: AsyncGraphPersister,
    templates: TransactionTemplates
) : AdminNotificationsDao {
    private val pkapTemplate = templates[POIROT_USERS]

    @InitRefreshables
    private object FeedableHolder {

        val feedable: RefreshableSet<AdminNotification> =
            refreshableSet(
                name = "NOTIFICATION_FEED",
                refresh = about1Min(),
                versionStrategy = incrementOnChange()
            ) {
                val now = now()

                findAll(
                    entity = adminNotification,
                    order = DESC,
                    orderBy = listOf(adminNotification.lastModified),
                    batch = false
                ) fetchFields {
                    allFieldsWithRelations
                } where {
                    dateFrom lessThanOrEqualTo now
                    dateTo greaterThanOrEqualTo now
                    archive `=` false
                    publish `=` true
                }
            }
    }

    override suspend fun insert(adminNotification: AdminNotification) {
        adminNotification.apply { persister.insert(listOf(adminNotification)) }
    }

    override suspend fun merge(adminNotification: AdminNotification) {
        pkapTemplate.inTransactionWithReactorContext {
            adminNotification.apply { persister.merge(listOf(adminNotification)) }
        }
    }

    override suspend fun fetchById(notificationId: Long): AdminNotification =
        (findFirst(entity = adminNotification, batch = false) fetchFields {
            allFieldsWithRelations
        } where {
            id `=` notificationId
        }) ?: throw FrontException(NOTIFICATION_NOT_FOUND)

    override suspend fun existsNotArchivedWithId(notificationId: Long): Boolean =
        existsAny(adminNotification, batch = false) where {
            id `=` notificationId
            archive `=` false
        }

    override suspend fun fetchAll(): List<AdminNotification> =
        findAll(entity = adminNotification, batch = false) fetchFields {
            allFieldsWithRelations
        } where {
            archive `=` false
        }

    override suspend fun feed(userRoleIds: Set<Int>): List<AdminNotification> {
        val res = feedable.asSet()
            .filterNot { it.mapping.isNullOrEmpty() }
            .filter { it.mapping.any { mapp -> userRoleIds.contains(mapp.roleId) } }

        return when {
            res.size > 3 -> res.slice(0..2)
            else -> res
        }
    }
}package ru.sber.poirot.notifications.admin.impl

import org.springframework.stereotype.Repository
import ru.sber.poirot.engine.datasources.PoirotDatabaseNames.POIROT_USERS
import ru.sber.poirot.engine.datasources.transaction.TransactionTemplates
import ru.sber.poirot.engine.ds.refreshable.RefreshableSet
import ru.sber.poirot.engine.ds.refreshable.Refreshables.refreshableSet
import ru.sber.poirot.engine.ds.refreshable.delayers.about1Min
import ru.sber.poirot.engine.ds.refreshable.incrementOnChange
import ru.sber.poirot.engine.dsl.Order.DESC
import ru.sber.poirot.engine.dsl.existsAny
import ru.sber.poirot.engine.dsl.findAll
import ru.sber.poirot.engine.dsl.findFirst
import ru.sber.poirot.exception.FrontException
import ru.sber.poirot.notifications.admin.impl.DslAdminNotificationsDao.FeedableHolder.feedable
import ru.sber.poirot.notifications.common.entity.AdminNotification
import ru.sber.poirot.notifications.common.error.NotificationErrorCode.NOTIFICATION_NOT_FOUND
import ru.sber.poirot.notifications.common.metamodel.adminNotification
import ru.sber.poirot.refreshable.InitRefreshables
import ru.sber.poirot.utils.inTransactionWithReactorContext
import ru.sber.sql.persister.AsyncGraphPersister
import java.time.LocalDateTime.now

@Repository
class DslAdminNotificationsDao(
    private val persister: AsyncGraphPersister,
    templates: TransactionTemplates
) : AdminNotificationsDao {
    private val pkapTemplate = templates[POIROT_USERS]

    @InitRefreshables
    private object FeedableHolder {

        val feedable: RefreshableSet<AdminNotification> =
            refreshableSet(
                name = "NOTIFICATION_FEED",
                refresh = about1Min(),
                versionStrategy = incrementOnChange()
            ) {
                val now = now()

                findAll(
                    entity = adminNotification,
                    order = DESC,
                    orderBy = listOf(adminNotification.lastModified),
                    batch = false
                ) fetchFields {
                    allFieldsWithRelations
                } where {
                    dateFrom lessThanOrEqualTo now
                    dateTo greaterThanOrEqualTo now
                    archive `=` false
                    publish `=` true
                }
            }
    }

    override suspend fun insert(adminNotification: AdminNotification) {
        adminNotification.apply { persister.insert(listOf(adminNotification)) }
    }

    override suspend fun merge(adminNotification: AdminNotification) {
        pkapTemplate.inTransactionWithReactorContext {
            adminNotification.apply { persister.merge(listOf(adminNotification)) }
        }
    }

    override suspend fun fetchById(notificationId: Long): AdminNotification =
        (findFirst(entity = adminNotification, batch = false) fetchFields {
            allFieldsWithRelations
        } where {
            id `=` notificationId
        }) ?: throw FrontException(NOTIFICATION_NOT_FOUND)

    override suspend fun existsNotArchivedWithId(notificationId: Long): Boolean =
        existsAny(adminNotification, batch = false) where {
            id `=` notificationId
            archive `=` false
        }

    override suspend fun fetchAll(): List<AdminNotification> =
        findAll(entity = adminNotification, batch = false) fetchFields {
            allFieldsWithRelations
        } where {
            archive `=` false
        }

    override suspend fun feed(userRoleIds: Set<Int>): List<AdminNotification> {
        val res = feedable.asSet()
            .filterNot { it.mapping.isNullOrEmpty() }
            .filter { it.mapping.any { mapp -> userRoleIds.contains(mapp.roleId) } }

        return when {
            res.size > 3 -> res.slice(0..2)
            else -> res
        }
    }
}package ru.sber.poirot.notifications.websocket

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.reactive.HandlerMapping
import org.springframework.web.reactive.handler.SimpleUrlHandlerMapping
import org.springframework.web.reactive.socket.server.support.WebSocketHandlerAdapter
import ru.sber.poirot.notifications.admin.AdminNotifications

@Configuration
class WebSocketConfig {

    @Bean
    fun feedWebSocketHandler(
        adminNotifications: AdminNotifications
    ): FeedWebSocketHandler = FeedWebSocketHandler(adminNotifications)

    @Bean
    fun webSocketHandlerMapping(feedWebSocketHandler: FeedWebSocketHandler): HandlerMapping {
        val map = mapOf("/ws/feed" to feedWebSocketHandler)
        return SimpleUrlHandlerMapping(map, -1)
    }

    @Bean
    fun handlerAdapter() = WebSocketHandlerAdapter()
}package ru.sber.poirot.notifications.websocket

import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import ru.sber.poirot.notifications.websocket.BroadcastRegistry.getConnectedClientsCount
import ru.sber.utils.logger

@Component
class NotificationExpirationScheduler {

    private val log = logger()

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∏—Å—Ç–µ–∫—à–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
     *
     * –ï—Å–ª–∏ —É –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ –µ—Å—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Å –∏—Å—Ç–µ–∫—à–∏–º dateTo,
     * –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∏–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –±–µ–∑ –∏—Å—Ç–µ–∫—à–∏—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
     */
    @Scheduled(fixedDelay = 30000, initialDelay = 30000)
    fun checkExpiredNotifications() {
        try {
            val clientsCount = getConnectedClientsCount()

            if (clientsCount == 0) {
                return
            }

            log.debug("‚è∞ Checking for expired notifications ({} connected clients)", clientsCount)

            val hasExpired = BroadcastRegistry.hasExpiredNotifications()

            if (hasExpired) {
                log.info("üóëÔ∏è Found expired notifications, refreshing all clients")
                BroadcastRegistry.refreshAll()
            }

        } catch (e: Exception) {
            log.error("‚ùå Error checking expired notifications: {}", e.message, e)
        }
    }
}package ru.sber.poirot.notifications.websocket

import kotlinx.coroutines.reactor.mono
import org.springframework.web.reactive.socket.WebSocketHandler
import org.springframework.web.reactive.socket.WebSocketSession
import org.springframework.web.reactive.socket.WebSocketMessage
import reactor.core.publisher.Mono
import reactor.core.publisher.Flux
import reactor.core.publisher.Sinks
import ru.sber.parseJson
import ru.sber.poirot.notifications.admin.AdminNotifications
import ru.sber.poirot.notifications.admin.dto.FeedResponse
import ru.sber.poirot.notifications.admin.dto.WsMessage
import ru.sber.toJson
import ru.sber.utils.logger
import java.time.Duration
import java.util.concurrent.atomic.AtomicLong

class FeedWebSocketHandler(
    private val adminNotifications: AdminNotifications
) : WebSocketHandler {

    private val log = logger()

    override fun handle(session: WebSocketSession): Mono<Void> {
        log.info("New WS connection: {}", session.id)
        val lastSeen = AtomicLong(System.currentTimeMillis())

        val receiveFlux = session.receive()
            .flatMap { msg ->
                lastSeen.set(System.currentTimeMillis())
                val payload = msg.payloadAsText

                try {
                    val wsMessage = payload.parseJson<WsMessage>()

                    when (wsMessage.type) {
                        WsMessage.Type.PING -> {
                            log.debug("Received PING from {}", session.id)
                            Mono.empty<Void>()
                        }

                        WsMessage.Type.SUBSCRIBE -> {
                            log.info("Processing SUBSCRIBE for session {}", session.id)

                            // 1Ô∏è‚É£ –ü–æ–ª—É—á–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                            mono {
                                val (feed, roleIds) = try {
                                    adminNotifications.feed()
                                } catch (e: Exception) {
                                    log.error("Failed to get feed for {}: {}", session.id, e.message, e)
                                    val errorMsg = WsMessage.error("Authentication failed: ${e.message}")
                                    session.send(Mono.just(session.textMessage(errorMsg.toJson()))).subscribe()
                                    return@mono Pair(emptyList<FeedResponse>(), emptySet<Int>())
                                }

                                log.info("Subscribed session {} with roles: {}, feed size: {}",
                                    session.id, roleIds, feed.size)

                                Pair(feed, roleIds)
                            }.flatMapMany { (feed, roleIds) ->

                                // 2Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                                val initial = if (feed.isNotEmpty()) {
                                    val msgText = WsMessage.data(feed).toJson()
                                    session.send(Mono.just(session.textMessage(msgText)))
                                } else {
                                    Mono.empty<Void>()
                                }

                                // 3Ô∏è‚É£ –°–æ–∑–¥–∞–µ–º –ø–æ—Ç–æ–∫ –¥–ª—è broadcast —Å–æ–±—ã—Ç–∏–π
                                val live = Flux.create<List<FeedResponse>> { sink ->
                                    // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º sink –≤ BroadcastRegistry
                                    BroadcastRegistry.register(session.id, session, roleIds, feed.toMutableList(), sink)
                                }

                                // 4Ô∏è‚É£ –û–±—ä–µ–¥–∏–Ω—è–µ–º: —Å–Ω–∞—á–∞–ª–∞ initial, –ø–æ—Ç–æ–º live —Å–æ–±—ã—Ç–∏—è
                                Flux.concat(
                                    initial.then(Mono.empty<WebSocketMessage>()),
                                    live.flatMap { feedList ->
                                        val msg = WsMessage.data(feedList).toJson()
                                        session.send(Mono.just(session.textMessage(msg)))
                                    }
                                )
                            }
                        }

                        else -> {
                            log.warn("Unknown WSMessage type: {} from {}", wsMessage.type, session.id)
                            val err = WsMessage.error("Unknown WSMessage type: ${wsMessage.type}")
                            session.send(Mono.just(session.textMessage(err.toJson()))).then()
                        }
                    }
                } catch (e: Exception) {
                    log.error("WS processing error for {}: {}", session.id, e.message, e)
                    val errorMsg = WsMessage.error("Invalid WSMessage: ${e.message}")
                    session.send(Mono.just(session.textMessage(errorMsg.toJson()))).then()
                }
            }
            .doFinally { signal ->
                log.info("Closing WS connection: {} by signal: {}", session.id, signal)
                BroadcastRegistry.unregister(session.id)
            }

        // Heartbeat
        val heartbeatFlux = heartbeat(lastSeen, session)

        return Flux.merge(receiveFlux, heartbeatFlux).then()
    }

    private fun heartbeat(lastSeen: AtomicLong, session: WebSocketSession): Flux<WebSocketMessage> =
        Flux.interval(Duration.ofSeconds(30))
            .flatMap {
                val now = System.currentTimeMillis()
                val timeSinceLastSeen = now - lastSeen.get()

                if (timeSinceLastSeen >= 90_000) {
                    log.warn("Session {} timed out (no activity for {}ms). Closing.",
                        session.id, timeSinceLastSeen)
                    BroadcastRegistry.unregister(session.id)
                    session.close().subscribe()
                    Mono.empty<WebSocketMessage>()
                } else {
                    log.debug("Sending PING to session {}", session.id)
                    val ping = session.textMessage(WsMessage.ping().toJson())
                    session.send(Mono.just(ping))
                        .doOnError { e ->
                            log.warn("Failed to send ping to {}: {}", session.id, e.message)
                            BroadcastRegistry.unregister(session.id)
                            session.close().subscribe()
                        }
                        .subscribe()
                    Mono.just(ping)
                }
            }
}package ru.sber.poirot.notifications.websocket

import org.springframework.web.reactive.socket.WebSocketSession
import reactor.core.publisher.FluxSink
import reactor.core.publisher.Sinks
import ru.sber.poirot.notifications.admin.dto.FeedResponse
import ru.sber.utils.logger
import java.time.LocalDateTime
import java.util.concurrent.ConcurrentHashMap

object BroadcastRegistry {

    private val log = logger()
    private val clients = ConcurrentHashMap<String, ConnectedClient>()

    data class ConnectedClient(
        val session: WebSocketSession,
        val roleIds: Set<Int>,
        val feed: MutableList<FeedResponse>,
        val sink: FluxSink<List<FeedResponse>>
    )

    fun register(
        sessionId: String,
        session: WebSocketSession,
        roleIds: Set<Int>,
        initialFeed: MutableList<FeedResponse>,
        sink: FluxSink<List<FeedResponse>>
    ) {
        clients[sessionId] = ConnectedClient(session, roleIds, initialFeed, sink)
        log.info("‚úÖ Registered session: {}, roleIds: {}, total clients: {}",
            sessionId, roleIds, clients.size)
        sink.onDispose { clients.remove(sessionId) }
    }

    fun unregister(sessionId: String) {
        clients.remove(sessionId)
        log.info("‚ùå Unregistered session: {}, remaining clients: {}", sessionId, clients.size)
    }

    fun publish(feedResponses: List<FeedResponse>) {
        log.info("üì¢ Broadcasting {} notifications to {} clients",
            feedResponses.size, clients.size)

        feedResponses.forEach { feed ->
            clients.values.forEach { client ->
                try {
                    processUpdate(client, feed)
                } catch (e: Exception) {
                    log.error("‚ùå Error processing update for session {}: {}",
                        client.session.id, e.message, e)
                    unregister(client.session.id)
                }
            }
        }
    }

    private fun cleanupDeadSessions() {
        val deadSessions = clients.filter { !it.value.session.isOpen }
        if (deadSessions.isNotEmpty()) {
            log.warn("üßπ Cleaning up {} dead sessions", deadSessions.size)
            deadSessions.forEach { (sessionId, _) ->
                unregister(sessionId)
            }
        }
    }

    private fun processUpdate(client: ConnectedClient, feed: FeedResponse) {
        val existingIndex = client.feed.indexOfFirst { it.id == feed.id }
        val shouldShow = shouldShowNotification(client, feed)

        when {
            !shouldShow && existingIndex != -1 -> {
                client.feed.removeAt(existingIndex)
                log.debug("‚ùå Removed notification {} from client {}",
                    feed.id, client.session.id)
            }
            shouldShow && existingIndex == -1 -> {
                client.feed.add(feed)
                log.debug("‚ûï Added notification {} to client {}",
                    feed.id, client.session.id)
            }
            shouldShow && existingIndex != -1 -> {
                client.feed[existingIndex] = feed
                log.debug("üîÑ Updated notification {} for client {}",
                    feed.id, client.session.id)
            }
        }

        // üü¢ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —á–µ—Ä–µ–∑ sink –≤–º–µ—Å—Ç–æ –ø—Ä—è–º–æ–≥–æ session.send()
        sendThroughSink(client)
    }

    private fun shouldShowNotification(client: ConnectedClient, feed: FeedResponse): Boolean {
        val now = LocalDateTime.now()
        return !feed.archived &&
                feed.publish &&
                hasRole(client, feed) &&
                !now.isBefore(feed.dateFrom) &&
                !now.isAfter(feed.dateTo)
    }

    private fun hasRole(client: ConnectedClient, feed: FeedResponse): Boolean {
        return feed.roleIds.isEmpty() || client.roleIds.any { it in feed.roleIds }
    }

    private fun sendThroughSink(client: ConnectedClient) {
        try {
            val activeMessages = client.feed.filter { feed ->
                shouldShowNotification(client, feed)
            }

            log.debug("üì® Emitting {} notifications to session {} via sink",
                activeMessages.size, client.session.id)

            // üü¢ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —á–µ—Ä–µ–∑ sink!
            client.sink.next(activeMessages)

        } catch (e: Exception) {
            log.error("‚ùå Error sending through sink for {}: {}",
                client.session.id, e.message, e)
            unregister(client.session.id)
        }
    }

    fun hasExpiredNotifications(): Boolean {
        val now = LocalDateTime.now()

        return clients.values.any { client ->
            client.feed.any { feed ->
                now.isAfter(feed.dateTo) || now.isBefore(feed.dateFrom)
            }
        }
    }

    fun refreshAll() {
        log.info("üîÑ Refreshing all {} connected clients", clients.size)

        cleanupDeadSessions()

        clients.forEach { (sessionId, client) ->
            try {
                sendThroughSink(client)
            } catch (e: Exception) {
                log.error("‚ùå Error refreshing session {}: {}", sessionId, e.message, e)
                unregister(sessionId)
            }
        }
    }

    fun getConnectedClientsCount(): Int = clients.size
}
