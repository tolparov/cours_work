@Component
class NotificationExpirationScheduler(
    private val adminNotificationsDao: AdminNotificationsDao
) {

    private val log = logger()

    /**
     * –ö–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –∫–ª–∏–µ–Ω—Ç–æ–≤ —Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º –∫–µ—à–µ–º.
     * –ö–µ—à –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞–∑ –≤ –º–∏–Ω—É—Ç—É (about1Min).
     */
    @Scheduled(fixedDelay = 30000, initialDelay = 30000)
    fun syncClientsFromCache() {
        try {
            val clientsCount = BroadcastRegistry.getConnectedClientsCount()
            
            if (clientsCount == 0) {
                return
            }
            
            log.debug("üîÑ Syncing {} connected clients from cache", clientsCount)
            
            // üü¢ –ß–∏—Ç–∞–µ–º –í–°–ï –∏–∑ –∫–µ—à–∞ (—É–∂–µ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ dateTo/dateFrom/publish/archive)
            val allNotifications = adminNotificationsDao.feedAll()
                .map { it.toFeedResponse() }
            
            if (allNotifications.isEmpty()) {
                log.debug("üì≠ No active notifications in cache")
                return
            }
            
            log.info("üì¢ Syncing {} notifications to {} clients from cache", 
                allNotifications.size, clientsCount)
            
            BroadcastRegistry.syncFromCache(allNotifications)
            
        } catch (e: Exception) {
            log.error("‚ùå Error syncing clients from cache: {}", e.message, e)
        }
    }
}
