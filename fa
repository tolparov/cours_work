@Scheduled(fixedDelay = 30000, initialDelay = 30000)
    fun syncClientsFromCache() {
        try {
            val clientsCount = BroadcastRegistry.getConnectedClientsCount()
            
            if (clientsCount == 0) {
                // –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ - –Ω–µ—á–µ–≥–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å
                return
            }
            
            log.debug("üîÑ Syncing {} connected clients from cache", clientsCount)
            
            // üü¢ –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫–µ—à–∞ –¥–ª—è "–≤—Å–µ—Ö —Ä–æ–ª–µ–π"
            // feed() –≤–µ—Ä–Ω–µ—Ç –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ, –Ω–æ –Ω–∞–º –Ω—É–∂–Ω—ã –í–°–ï
            // –ü–æ—ç—Ç–æ–º—É –∏—Å–ø–æ–ª—å–∑—É–µ–º fetchAll() –∏–ª–∏ –ø—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ –∫–µ—à—É
            val allNotifications = adminNotificationsDao.fetchAll()
                .filter { it.publish && !it.archive }
                .map { it.toFeedResponse() }
            
            if (allNotifications.isEmpty()) {
                log.debug("üì≠ No active notifications in cache")
                return
            }
            
            log.info("üì¢ Syncing {} notifications to {} clients from cache", 
                allNotifications.size, clientsCount)
            
            // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –≤—Å–µ—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ –Ω–∞ –≠–¢–û–ú –ø–æ–¥–µ
            BroadcastRegistry.syncFromCache(allNotifications)
            
        } catch (e: Exception) {
            log.error("‚ùå Error syncing clients from cache: {}", e.message, e)
        }
    }


fun syncFromCache(allNotifications: List<FeedResponse>) {
        if (clients.isEmpty()) {
            return
        }
        
        log.info("üîÑ [{}] Syncing {} notifications to {} clients from cache", 
            POD_ID, allNotifications.size, clients.size)
        
        cleanupDeadSessions()
        
        clients.values.toList().forEach { client ->
            try {
                syncClientFromCache(client, allNotifications)
            } catch (e: Exception) {
                log.error("‚ùå Error syncing client {}: {}", 
                    client.session.id, e.message, e)
                unregister(client.session.id)
            }
        }
    }

    private fun syncClientFromCache(
        client: ConnectedClient,
        allNotifications: List<FeedResponse>
    ) {
        // –§–∏–ª—å—Ç—Ä—É–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –¥–ª—è —ç—Ç–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
        val relevantForClient = allNotifications.filter { notification ->
            shouldShowNotification(client, notification)
        }
        
        // –ü–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–º–µ–Ω—è–µ–º feed –∫–ª–∏–µ–Ω—Ç–∞ –∞–∫—Ç—É–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
        client.feed.clear()
        client.feed.addAll(relevantForClient)
        
        log.debug("üì® [{}] Synced client {}: {} notifications", 
            POD_ID, client.session.id, relevantForClient.size)
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∫–ª–∏–µ–Ω—Ç—É
        sendThroughSink(client)
    }
