package ru.sber.poirot.basket.api.impl

import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import org.springframework.stereotype.Service
import ru.sber.poirot.basket.api.UnifiedBasket
import ru.sber.poirot.basket.api.impl.RequestFilter.Companion.filterFrom
import ru.sber.poirot.basket.api.model.RecordsRequest
import ru.sber.poirot.basket.common.RecordsResponse
import ru.sber.poirot.basket.common.SourceResponse
import ru.sber.poirot.paging.forPageWith
import ru.sber.poirot.basket.common.toRecords
import ru.sber.utils.optimizedPartition
import ru.sber.poirot.basket.api.impl.ProcessType.MON_KSB
import ru.sber.poirot.basket.common.BasketRecord
import ru.sber.poirot.basket.common.sortedBy
import ru.sber.poirot.basket.common.toErrorMessages
import ru.sber.poirot.userinfoprovider.UserInfoProvider

@Service
class UnifiedBasketImpl(
    private val basketLoaders: List<BasketLoader>,
    private val userInfoProvider: UserInfoProvider
) : UnifiedBasket {

    override suspend fun loadRecords(request: RecordsRequest): RecordsResponse =
        loadRecordsInternal(
            request, includeStatusFilter = true, withPagination = false, withSorting = false)

    override suspend fun loadFlowRecords(request: RecordsRequest): RecordsResponse =
        loadRecordsInternal(
            request, includeStatusFilter = false, withPagination = true, withSorting = true)

    private suspend fun loadRecordsInternal(
        request: RecordsRequest,
        includeStatusFilter: Boolean,
        withPagination: Boolean,
        withSorting: Boolean,
    ): RecordsResponse {
        val requestFilter = filterFrom(request, includeStatusFilter)
        val effectiveTypes = getEffectiveTypes(requestFilter.types)

        val (successResponses, errorResponses) = basketLoaders
            .filter { it.type in effectiveTypes }
            .loadRecords(request)
            .optimizedPartition { it.success }

        val filteredRecords = successResponses.toRecords()
            .map { mapRecordType(it) }
            .filter { requestFilter.check(it) }

        val sortedRecords = applySorting(filteredRecords, request, withSorting)
        val (paginatedRecords, totalCount) = applyPagination(sortedRecords, request, withPagination)

        return RecordsResponse(
            records = paginatedRecords,
            warningMessages = errorResponses.toErrorMessages(),
            totalCount = totalCount
        )
    }

    private fun getEffectiveTypes(types: List<ProcessType>): List<ProcessType> =
        types.map { if (it == MON_KSB) ProcessType.FOCUS_MONITORING else it }

    private fun mapRecordType(record: BasketRecord): BasketRecord {
        val processType = (record.record.metadata as? Map<*, *>)?.get("processType")
        val type = when {
            record.type == ProcessType.FOCUS_MONITORING.type && processType == 11 -> MON_KSB.type
            record.type == ProcessType.FOCUS_MONITORING.type && processType == 12 -> MON_KSB.type
            else -> record.type
        }
        return record.copy(type = type)
    }

    private fun applySorting(
        records: List<BasketRecord>,
        request: RecordsRequest,
        withSorting: Boolean
    ): List<BasketRecord> =
        if (withSorting) {
            records.sortedBy(request.sortField, request.sortOrder)
        } else {
            records
        }

    private suspend fun applyPagination(
        records: List<BasketRecord>,
        request: RecordsRequest,
        withPagination: Boolean
    ): Pair<List<BasketRecord>, Int?> =
        if (withPagination) {
            val rowsOnPage = request.rowsOnPage ?: -1
            val offset = request.offset
            val total = records.size
            val paginatedRecords = records.forPageWith(offset, rowsOnPage).map { enrichWithExecutorFio(it) }
            paginatedRecords to total
        } else {
            records to null
        }

    private suspend fun enrichWithExecutorFio(record: BasketRecord): BasketRecord {
        val executorUsername = record.record.executorFio
        return if (executorUsername != null) {
            val executorFio = userInfoProvider.getFioByUsername(executorUsername)
            record.copy(
                record = record.record.copy(executorFio = executorFio)
            )
        } else {
            record
        }
    }

    private suspend fun List<BasketLoader>.loadRecords(request: RecordsRequest): List<SourceResponse> = coroutineScope {
        map { loader -> async { loader.getRecords(request) } }.awaitAll()
    }
}
