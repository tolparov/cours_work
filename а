package ru.sber.poirot.notifications.websocket

import org.springframework.web.reactive.socket.WebSocketSession
import reactor.core.publisher.Mono
import ru.sber.poirot.notifications.admin.dto.FeedResponse
import ru.sber.poirot.notifications.admin.dto.WsMessage
import ru.sber.toJson
import ru.sber.utils.logger
import java.util.concurrent.ConcurrentHashMap

object BroadcastRegistry {

    private val log = logger()
    private val clients = ConcurrentHashMap<String, ConnectedClient>()

    data class ConnectedClient(
        val session: WebSocketSession,
        val roleIds: Set<Int>,
        val feed: MutableList<FeedResponse> = mutableListOf()
    )

    fun register(
        sessionId: String,
        session: WebSocketSession,
        roleIds: Set<Int>,
        initialFeed: List<FeedResponse>
    ) {
        clients[sessionId] = ConnectedClient(session, roleIds, initialFeed.toMutableList())
        log.info("Registered session: {}, total clients: {}", sessionId, clients.size)
    }

    fun unregister(sessionId: String) {
        clients.remove(sessionId)
        log.info("Unregistered session: {}, remaining clients: {}", sessionId, clients.size)
    }

    fun publish(feedResponses: List<FeedResponse>) {
        // üü¢ –û—á–∏—Å—Ç–∫–∞ –º–µ—Ä—Ç–≤—ã—Ö —Å–µ—Å—Å–∏–π –ø–µ—Ä–µ–¥ broadcast
        cleanupDeadSessions()

        feedResponses.forEach { feed ->
            clients.forEach { (sessionId, client) ->
                try {
                    processUpdate(sessionId, client, feed)
                } catch (e: Exception) {
                    log.error("Error processing update for session {}: {}", sessionId, e.message, e)
                    unregister(sessionId)
                }
            }
        }
    }

    private fun cleanupDeadSessions() {
        val deadSessions = clients.filter { !it.value.session.isOpen }
        deadSessions.forEach { (sessionId, _) ->
            log.warn("Removing dead session: {}", sessionId)
            unregister(sessionId)
        }
    }

    private fun processUpdate(sessionId: String, client: ConnectedClient, feed: FeedResponse) {
        val hasRole = feed.roleIds.isEmpty() || client.roleIds.any { it in feed.roleIds }
        val existingIndex = client.feed.indexOfFirst { it.id == feed.id }

        when {
            // üü¢ –°–õ–£–ß–ê–ô 1: –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–æ
            feed.archived -> {
                if (existingIndex != -1) {
                    client.feed.removeAt(existingIndex)
                    send(client, WsMessage.delete(listOf(feed.id)))  // üéØ –£–ø—Ä–æ—â–µ–Ω–æ
                    log.debug("Sent DELETE for notification {} to session {}", feed.id, sessionId)
                }
            }

            // üü¢ –°–õ–£–ß–ê–ô 2: –†–æ–ª–∏ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±–æ–ª—å—à–µ –Ω–µ –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø–∞
            existingIndex != -1 && !hasRole -> {
                client.feed.removeAt(existingIndex)
                send(client, WsMessage.delete(listOf(feed.id)))  // üéØ –£–ø—Ä–æ—â–µ–Ω–æ
                log.debug("Removed notification {} from session {} (role access revoked)", feed.id, sessionId)
            }

            // üü¢ –°–õ–£–ß–ê–ô 3: –ù–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            existingIndex == -1 && hasRole -> {
                client.feed.add(feed)
                send(client, WsMessage.data(listOf(feed)))  // üéØ –£–ø—Ä–æ—â–µ–Ω–æ
                log.debug("Added new notification {} to session {}", feed.id, sessionId)
            }

            // üü¢ –°–õ–£–ß–ê–ô 4: –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            existingIndex != -1 && hasRole -> {
                client.feed[existingIndex] = feed
                send(client, WsMessage.data(listOf(feed)))  // üéØ –£–ø—Ä–æ—â–µ–Ω–æ
                log.debug("Updated notification {} for session {}", feed.id, sessionId)
            }
        }
    }

    // üéØ –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–´–ô –º–µ—Ç–æ–¥ –æ—Ç–ø—Ä–∞–≤–∫–∏ (–≤–º–µ—Å—Ç–æ sendData –∏ sendDelete)
    private fun send(client: ConnectedClient, wsMessage: WsMessage) {
        try {
            val json = wsMessage.toJson()
            client.session.send(Mono.just(client.session.textMessage(json)))
                .doOnError { e ->
                    log.error("Failed to send {} to {}: {}", 
                        wsMessage.type, client.session.id, e.message)
                    unregister(client.session.id)
                }
                .subscribe()
        } catch (e: Exception) {
            log.error("Error sending {} message to {}", 
                wsMessage.type, client.session.id, e)
            unregister(client.session.id)
        }
    }

    // üÜï –ú–µ—Ç–æ–¥—ã –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    fun getConnectedClientsCount(): Int = clients.size
    
    fun getClientsByRole(roleId: Int): Int = 
        clients.count { it.value.roleIds.contains(roleId) }
    
    fun getAllSessions(): List<String> = clients.keys.toList()
}
