24.10 17:20:02.567  INFO [Dispatcher-worker-1] ru.sber.poirot.audit.dao.AuditDao       : Found 501 events in 98 ms.
24.10 17:20:03.066  INFO [eactor-http-epoll-2] r.s.p.a.websocket.AuditWebSocketHandler : Closing WS connection: 79b7af34
24.10 17:21:26.365  INFO [poirot_users-dsl-03] ru.sber.poirot.audit.dao.AuditDao       : Found 1 events in 6 ms.
24.10 17:24:38.824  INFO [eactor-http-epoll-2] r.s.p.a.websocket.AuditWebSocketHandler : New WS connection: 42358456
24.10 17:24:38.913  INFO [Dispatcher-worker-1] ru.sber.poirot.audit.dao.AuditDao       : Found 501 events in 18 ms.
24.10 17:24:38.933  INFO [eactor-http-epoll-2] r.s.p.a.websocket.AuditWebSocketHandler : Closing WS connection: 42358456
24.10 17:27:35.761  INFO [eactor-http-epoll-3] r.s.p.a.websocket.AuditWebSocketHandler : New WS connection: 60e89762
24.10 17:27:35.800  INFO [Dispatcher-worker-2] ru.sber.poirot.audit.dao.AuditDao       : Found 501 events in 14 ms.
24.10 17:27:35.841  INFO [eactor-http-epoll-3] r.s.p.a.websocket.AuditWebSocketHandler : Closing WS connection: 60e89762
24.10 17:27:49.814  INFO [eactor-http-epoll-3] r.s.p.a.websocket.AuditWebSocketHandler : New WS connection: 43b42d39
24.10 17:27:49.853  INFO [Dispatcher-worker-2] ru.sber.poirot.audit.dao.AuditDao       : Found 501 events in 15 ms.
24.10 17:27:49.866  INFO [eactor-http-epoll-3] r.s.p.a.websocket.AuditWebSocketHandler : Closing WS connection: 43b42d39
24.10 17:27:57.707  INFO [eactor-http-epoll-3] r.s.p.a.websocket.AuditWebSocketHandler : New WS connection: 20dabaf1
24.10 17:27:57.756  INFO [Dispatcher-worker-2] ru.sber.poirot.audit.dao.AuditDao       : Found 501 events in 14 ms.
24.10 17:27:57.767  INFO [eactor-http-epoll-3] r.s.p.a.websocket.AuditWebSocketHandler : Closing WS connection: 20dabaf1
24.10 17:28:11.250  INFO [eactor-http-epoll-3] r.s.p.a.websocket.AuditWebSocketHandler : New WS connection: 133be4fd
24.10 17:28:11.322  INFO [Dispatcher-worker-2] ru.sber.poirot.audit.dao.AuditDao       : Found 501 events in 7 ms.
24.10 17:28:11.331  INFO [eactor-http-epoll-3] r.s.p.a.websocket.AuditWebSocketHandler : Closing WS connection: 133be4fd
24.10 17:28:30.591  INFO [eactor-http-epoll-3] r.s.p.a.websocket.AuditWebSocketHandler : New WS connection: 19258635
24.10 17:28:30.668  INFO [Dispatcher-worker-2] ru.sber.poirot.audit.dao.AuditDao       : Found 501 events in 12 ms.
24.10 17:28:30.677  INFO [eactor-http-epoll-3] r.s.p.a.websocket.AuditWebSocketHandler : Closing WS connection: 19258635
24.10 17:28:34.664  INFO [eactor-http-epoll-1] r.s.p.a.websocket.AuditWebSocketHandler : New WS connection: 77fa27f3
24.10 17:28:34.748  INFO [Dispatcher-worker-2] ru.sber.poirot.audit.dao.AuditDao       : Found 501 events in 10 ms.
24.10 17:28:34.757  INFO [eactor-http-epoll-1] r.s.p.a.websocket.AuditWebSocketHandler : Closing WS connection: 77fa27f3
24.10 17:29:13.800  INFO [eactor-http-epoll-3] r.s.p.a.websocket.AuditWebSocketHandler : New WS connection: 872cbc4
24.10 17:29:13.839  INFO [Dispatcher-worker-2] ru.sber.poirot.audit.dao.AuditDao       : Found 501 events in 7 ms.
24.10 17:29:13.847  INFO [eactor-http-epoll-3] r.s.p.a.websocket.AuditWebSocketHandler : Closing WS connection: 872cbc4 
начал тестировать с ui получает от него приходит запрос и сразу закрывается соединение package ru.sber.poirot.audit.websocket

import kotlinx.coroutines.reactor.mono
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.web.reactive.socket.*
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import ru.sber.parseJson
import ru.sber.permissions.HAS_AUDIT_READ
import ru.sber.poirot.audit.dao.Audit
import ru.sber.poirot.audit.model.AuditEvent
import ru.sber.poirot.audit.model.WsMessage
import ru.sber.toJson
import ru.sber.utils.logger
import java.time.Duration
import java.util.concurrent.atomic.AtomicLong

class AuditWebSocketHandler(
    private val auditDao: Audit
) : WebSocketHandler {

    private val log = logger()

    @PreAuthorize(HAS_AUDIT_READ)
    override fun handle(session: WebSocketSession): Mono<Void> {
        log.info("New WS connection: {}", session.id)
        val lastSeen = AtomicLong(System.currentTimeMillis())

        // Основная обработка входящих сообщений
        val receiveFlux = session.receive()
            .flatMap { msg ->
                lastSeen.set(System.currentTimeMillis())
                try {
                    val filter = msg.payloadAsText.parseJson<SubscriptionFilter>()

                    val historical = mono {
                        auditDao.filter(filter.dateFrom, filter.dateTo, filter.login)
                    }.flatMapMany { historicalEvents ->
                        if (historicalEvents.isNotEmpty()) {
                            val historicalMessage = WsMessage.data(historicalEvents).toJson()
                            session.send(Mono.just(session.textMessage(historicalMessage)))
                                .thenMany(Flux.empty<WebSocketMessage>())
                        } else {
                            Flux.empty<WebSocketMessage>()
                        }
                    }

                    val live = Flux.create<AuditEvent> { sink ->
                        BroadcastRegistry.register(session.id, filter, sink)
                    }


                    Flux.concat(
                        historical,
                        live.flatMap {  event ->
                            val msg = WsMessage.data(listOf(event)).toJson()
                            session.send(Mono.just(session.textMessage(msg)))
                        }
                    )
                } catch (e: Exception) {
                    val errorMsg = WsMessage.error("Некорректные данные: ${e.message}")
                    session.send(Mono.just(session.textMessage(errorMsg.toJson()))).then()
                }
            }.doFinally {
                log.info("Closing WS connection: {}", session.id)
                BroadcastRegistry.unregister(session.id)
            }
        // Heartbeat: только отправка ping + проверка таймаута
        val heartbeatFlux = Flux.interval(Duration.ofSeconds(180))
            .flatMap {
                val now = System.currentTimeMillis()
                if (now - lastSeen.get() >= 600_000) {
                    log.warn("Session {} did not respond to heartbeat. Closing.", session.id)
                    BroadcastRegistry.unregister(session.id)
                    session.close().subscribe()
                    Mono.empty<WebSocketMessage>()
                } else {
                    val ping = session.textMessage(WsMessage.ping().toJson())
                    session.send(Mono.just(ping))
                        .doOnError { e ->
                            log.warn("Failed to send ping to {}: {}", session.id, e.message)
                            BroadcastRegistry.unregister(session.id)
                            session.close().subscribe()
                        }
                        .subscribe()
                    Mono.just(ping)
                }
            }

        return Flux.merge(receiveFlux, heartbeatFlux).then()
    }

    fun broadcast(event: AuditEvent) {
        BroadcastRegistry.publish(event)
    }
}
{dateFrom: "2025-10-23T17:30", dateTo: "2025-10-24T17:30", login: ""}
dateFrom
: 
"2025-10-23T17:30"
dateTo
: 
"2025-10-24T17:30"
login
: 
""
 почему так может быть 
