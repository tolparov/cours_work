suspend fun fetchUlDebts(inns: List<String>): List<UlDebtDto> =
    findAll(
        fields = listOf(
            arrearsClientUl.inn,
            arrearsAgreement.debtAmount,
            arrearsAgreement.curDebtOverAmount,
            arrearsAgreement.curPercOverAmount,
            arrearsAgreement.curDebtOverDate,
            arrearsAgreement.curPercOverDate
        ),
        batch = true
    ) join {
        arrearsRoleLink.customerId `=` arrearsClientUl.customerId
        arrearsAgreement.agreementId `=` arrearsRoleLink.agreementId
    } where {
        arrearsClientUl.inn `in` inns and
                arrearsRoleLink.role `=` "Заемщик"
    } convertTo {
        val inn = nextField<String>()
        val totalCurrentDebt = nextField<Double?>() ?: 0.0
        val curDebtOver = nextField<Double?>() ?: 0.0
        val curPercOver = nextField<Double?>() ?: 0.0
        val curDebtOverDate = nextField<LocalDate?>()
        val curPercOverDate = nextField<LocalDate?>()

        UlDebtDto(
            clientInn = inn,
            totalCurrentDebt = totalCurrentDebt,
            totalOverdueDebt = curDebtOver + curPercOver,
            prncpOverdueDays = daysBetweenToday(curDebtOverDate),
            intrstOverdueDays = daysBetweenToday(curPercOverDate)
        )
    }
suspend fun fetchFlDebts(fioDobs: List<String>): List<FlDebtDto> {
    return fioDobs.flatMap { fioDob ->
        val parts = fioDob.split("|")
        if (parts.size !in 3..4) {
            throw FrontException(INCORRECT_ROW_SIZE.description)
        }

        val lastName = parts[0]
        val firstName = parts[1]
        val middleName = parts.getOrNull(2)?.takeIf { it.isNotBlank() }
        val birthDate = LocalDate.parse(parts.last(), DateTimeFormatter.ofPattern("dd.MM.yyyy"))

        val clients = findAll(entity = arrearsClientFl, batch = false) fetchFields {
            listOf(arrearsClientFl.customerId)
        } where {
            arrearsClientFl.lastName `=` lastName.inlined and
                    arrearsClientFl.firstName `=` firstName.inlined and
                    arrearsClientFl.birthDate `=` birthDate.inlined and
                    (middleName?.let { arrearsClientFl.middleName `=` it.inlined }
                        ?: arrearsClientFl.middleName.isNull())
        }

        clients.flatMap { client ->
            findAll(
                fields = listOf(
                    arrearsAgreement.agreementId,
                    arrearsAgreement.debtAmount,
                    arrearsAgreement.curDebtOverAmount,
                    arrearsAgreement.curPercOverAmount,
                    arrearsAgreement.curDebtOverDate,
                    arrearsAgreement.curPercOverDate
                ),
                batch = false
            ) join {
                arrearsRoleLink.customerId `=` client.customerId.inlined and
                        arrearsAgreement.agreementId `=` arrearsRoleLink.agreementId
            } where {
                arrearsRoleLink.role `=` "Заемщик".inlined
            } convertTo {
                val agreementId = nextField<String>()
                val totalCurrentDebt = nextField<Double?>() ?: 0.0
                val curDebtOver = nextField<Double?>() ?: 0.0
                val curPercOver = nextField<Double?>() ?: 0.0
                val curDebtOverDate = nextField<LocalDate?>()
                val curPercOverDate = nextField<LocalDate?>()

                FlDebtDto(
                    agreementId = agreementId,
                    clientFioDob = fioDob,
                    totalCurrentDebt = totalCurrentDebt,
                    totalOverdueDebt = curDebtOver + curPercOver,
                    prncpOverdueDays = daysBetweenToday(curDebtOverDate),
                    intrstOverdueDays = daysBetweenToday(curPercOverDate)
                )
            }
        }
    }
}
