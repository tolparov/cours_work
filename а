package ru.sber.poirot.notifications.websocket

import org.springframework.web.reactive.socket.WebSocketSession
import reactor.core.publisher.Mono
import ru.sber.poirot.notifications.admin.dto.FeedResponse
import ru.sber.poirot.notifications.admin.dto.WsMessage
import ru.sber.toJson
import java.util.concurrent.ConcurrentHashMap

object BroadcastRegistry {

    private val clients = ConcurrentHashMap<String, ConnectedClient>()

    data class ConnectedClient(
        val session: WebSocketSession,
        val roleIds: Set<Int>,
        val feed: MutableList<FeedResponse> = mutableListOf()
    )

    fun register(
        sessionId: String,
        session: WebSocketSession,
        roleIds: Set<Int>,
        initialFeed: List<FeedResponse>
    ) {
        clients[sessionId] = ConnectedClient(session, roleIds, initialFeed.toMutableList())
    }

    fun unregister(sessionId: String) {
        clients.remove(sessionId)
    }

    fun publish(feedResponses: List<FeedResponse>) {
        feedResponses.forEach { feed ->
            clients.forEach { (_, client) ->
                if (!client.session.isOpen) return@forEach

                val hasRole = client.roleIds.any { it in feed.roleIds }
                val existingIndex = client.feed.indexOfFirst { it.id == feed.id }

                when {
                    // üîπ –ê—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–æ ‚Üí —É–¥–∞–ª–∏—Ç—å, –µ—Å–ª–∏ –µ—Å—Ç—å
                    feed.archived -> {
                        if (existingIndex != -1) {
                            client.feed.removeAt(existingIndex)
                            sendUpdate(client, listOf(feed.copy(message = "REMOVED", type = "ARCHIVED")))
                        }
                    }

                    // üîπ –ù–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ (create)
                    existingIndex == -1 && hasRole -> {
                        client.feed.add(feed)
                        sendUpdate(client, listOf(feed))
                    }

                    // üîπ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ (update)
                    existingIndex != -1 && hasRole -> {
                        client.feed[existingIndex] = feed
                        sendUpdate(client, listOf(feed))
                    }
                }
            }
        }
    }

    private fun sendUpdate(client: ConnectedClient, feeds: List<FeedResponse>) {
        val wsMsg = WsMessage.data(feeds).toJson()
        client.session.send(Mono.just(client.session.textMessage(wsMsg))).subscribe()
    }
}
package ru.sber.poirot.notifications.admin.dto

import com.fasterxml.jackson.annotation.JsonIgnore
import ru.sber.poirot.notifications.common.entity.AdminNotification

class FeedResponse(
    val id: Long,
    val type: String,
    val message: String,
    val archived: Boolean,   // üîπ –Ω–æ–≤–æ–µ –ø–æ–ª–µ
    @JsonIgnore
    val roleIds: List<Int> = emptyList()
)

fun AdminNotification.toFeedResponse(): FeedResponse =
    FeedResponse(
        id = id,
        type = type,
        message = message,
        archived = archive, // –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, –ø–æ–ª–µ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è archive –≤ —Å—É—â–Ω–æ—Å—Ç–∏
        roleIds = mapping?.map { it.roleId } ?: emptyList()
    )
package ru.sber.poirot.notifications.websocket

import org.springframework.web.reactive.socket.WebSocketSession
import reactor.core.publisher.Mono
import ru.sber.poirot.notifications.admin.dto.FeedResponse
import ru.sber.poirot.notifications.admin.dto.WsMessage
import ru.sber.toJson
import java.util.concurrent.ConcurrentHashMap

object BroadcastRegistry {

    private val clients = ConcurrentHashMap<String, ConnectedClient>()

    data class ConnectedClient(
        val session: WebSocketSession,
        val roleIds: Set<Int>,
        val feed: MutableList<FeedResponse> = mutableListOf()
    )

    fun register(
        sessionId: String,
        session: WebSocketSession,
        roleIds: Set<Int>,
        initialFeed: List<FeedResponse>
    ) {
        clients[sessionId] = ConnectedClient(session, roleIds, initialFeed.toMutableList())
    }

    fun unregister(sessionId: String) {
        clients.remove(sessionId)
    }

    fun publish(feedResponses: List<FeedResponse>) {
        feedResponses.forEach { feed ->
            clients.forEach { (_, client) ->
                if (!client.session.isOpen) return@forEach

                val hasRole = client.roleIds.any { it in feed.roleIds }
                val existingIndex = client.feed.indexOfFirst { it.id == feed.id }

                when {
                    // üîπ –ê—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–æ ‚Üí —É–¥–∞–ª–∏—Ç—å, –µ—Å–ª–∏ –µ—Å—Ç—å
                    feed.archived -> {
                        if (existingIndex != -1) {
                            client.feed.removeAt(existingIndex)
                            sendUpdate(client, listOf(feed.copy(message = "REMOVED", type = "ARCHIVED")))
                        }
                    }

                    // üîπ –ù–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ (create)
                    existingIndex == -1 && hasRole -> {
                        client.feed.add(feed)
                        sendUpdate(client, listOf(feed))
                    }

                    // üîπ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ (update)
                    existingIndex != -1 && hasRole -> {
                        client.feed[existingIndex] = feed
                        sendUpdate(client, listOf(feed))
                    }
                }
            }
        }
    }

    private fun sendUpdate(client: ConnectedClient, feeds: List<FeedResponse>) {
        val wsMsg = WsMessage.data(feeds).toJson()
        client.session.send(Mono.just(client.session.textMessage(wsMsg))).subscribe()
    }
}
