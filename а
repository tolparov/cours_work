val historical = mono {
    auditDao.filter(filter.dateFrom, filter.dateTo, filter.login)
}.flatMapMany { events ->
    if (events.isNotEmpty()) {
        // Отправляем все исторические события ОДНИМ сообщением
        val dto = WsMessage.data(events)
        val msg = session.textMessage(dto.toJson())
        session.send(Mono.just(msg)).thenMany(Flux.empty())
    } else {
        Flux.empty()
    }
}
Flux.concat(
    historical,
    Flux.create<AuditEvent> { sink ->
        BroadcastRegistry.register(session.id, filter, sink)
        sink.onDispose { BroadcastRegistry.unregister(session.id) }
    }.map { event ->
        // live-события отправляем по одному
        WsMessage.data(listOf(event)).toJson()
    }.map { session.textMessage(it) }
     .flatMap { session.send(Mono.just(it)) }
).then()
